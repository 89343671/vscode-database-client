<html>

<head>
    <title>result</title>
    <link rel="stylesheet" href="/css/element.css">
    <link rel="stylesheet" href="/css/result.css">
    <script src="/js/vue.js"></script>
    <script src="/js/element.js"></script>
</head>

<body>
    <div id="app">
        <include path="components/toolPanel.html" />
        <!-- talbe result -->
        <div :style="'width:' + table.width + 'px;overflow:scroll'" v-if="result.data">
            <el-table id="dataTable" v-loading='table.loading' size='small' @sort-change="sort"
                :row-class-name="tableRowClassName" ref="dataTable"
                :data="result.data.filter(data => !table.search || JSON.stringify(data).toLowerCase().includes(table.search.toLowerCase()))"
                border @row-dblclick="row=>openEdit(row)">
                <!-- tool bar -->
                <include path="components/toolbar.html" />
                <!-- data  -->
                <include path="components/dataTable.html" />
            </el-table>
        </div>
        <include path="components/editDialog.html" />
    </div>
</body>

<script>
    const vscode = acquireVsCodeApi();
    // const previousState = vscode.getState();
    const previousState = false;
    const vue = new Vue({
        el: '#app',
        data: {
            result: {
                data: [],
                sql: '',
                primaryKey: null,
                columnList: null,
                database: null,
                table: null
            },
            table: {
                search: '',
                loading: true,
                width: null,
                widthItem: {}
            },
            toolbar: {
                sql: null,
                costTime: 0,
                isRefrsh: false,
                filter: {},
                showColumns: []
            },
            editor: {
                visible: false,
                loading: false
            },
            info: {
                sql: null,
                message: null,
                visible: false,
                error: false
            },
            update: {
                current: {},
                currentNew: {},
                primary: null
            }
        },
        methods: {
            filter(event, column) {

                let inputvalue = "" + event.target.value

                let filterSql = this.result.sql.replace(/\n/, " ").replace(";", " ") + " "

                let existsCheck = new RegExp(`(WHERE|AND)?\\s*${column}\\s*=\\s*.+?\\s`, 'igm');

                if (inputvalue) {
                    inputValue = "" + inputvalue
                    if (existsCheck.exec(filterSql)) {
                        // condition present
                        filterSql = filterSql.replace(existsCheck, `$1 ${column}='${inputValue}' `)
                    } else if (filterSql.match(/\bwhere\b/ig) && inputvalue) {
                        //have where
                        filterSql = filterSql.replace(/\b(where)\b/ig, `\$1 ${column}='${inputvalue}' AND `)
                    } else if (inputvalue) {
                        //have not where
                        filterSql = filterSql.replace(new RegExp(`(from\\s*.+?)\\s`, 'ig'), `\$1 WHERE ${column}='${inputvalue}' `)
                    }
                } else {
                    // empty value, clear filter
                    let beforeAndCheck = new RegExp(`${column}\\s*=\\s*.+?\\s*AND`, 'igm');
                    if (beforeAndCheck.exec(filterSql)) {
                        filterSql = filterSql.replace(beforeAndCheck, "")
                    } else {
                        filterSql = filterSql.replace(existsCheck, " ")
                    }
                }

                this.execute(filterSql + ";")
            },
            resetFilter() {
                this.execute(
                    this.result.sql.replace(/where.+?\b(order|limit|group)\b/ig, "$1")
                )
            },
            sort(row) {
                let order = row.order == 'ascending' ? "asc" : "desc"
                let sortSql = this.result.sql
                    .replace(/\n/, " ").replace(";", "")
                    .replace(/order by .+? (desc|asc)?/ig, "")
                    .replace(/\s?(limit.+)?$/i, ` ORDER BY ${row.column.label} ${order} \$1 `)
                this.execute(sortSql + ";")
            },
            insertRequest() {
                this.editor.visible = true;
                this.update.primary = null;
                this.update.currentNew = {};
            },
            confirmInsert() {
                let columns = "";
                let values = "";
                for (const key in this.update.currentNew) {
                    const newEle = this.update.currentNew[key];
                    if (newEle) {
                        columns += `${key},`;
                        values += `'${newEle.replace(/'/g, "\\'")}',`;
                    }
                }
                if (values) {
                    const insertSql = `INSERT INTO ${this.result.table}(${columns.replace(/,$/, "")}) VALUES(${values.replace(/,$/, "")})`
                    this.execute(insertSql)
                } else {
                    this.$message("Not any input, update fail!")
                }
            },
            confirmUpdate() {
                let change = "";
                for (const key in this.update.currentNew) {
                    const oldEle = this.update.current[key];
                    const newEle = this.update.currentNew[key];
                    if (oldEle != newEle) {
                        change += `${key}='${newEle.replace(/'/g, "\\'")}',`
                    }
                }
                if (change) {
                    const updateSql = `UPDATE ${this.result.table} SET ${change.replace(/,$/, "")} WHERE ${this.result.primaryKey}=${this.update.primary}`
                    this.execute(updateSql)
                } else {
                    this.$message("Not any change, update fail!")
                }
            },
            openEdit(row) {
                this.editor.visible = true;
                this.update = {
                    current: row,
                    currentNew: this.clone(row),
                    primary: row[this.result.primaryKey]
                }
            },
            uploadRole() {
                if (this.result.columnList == null) return;
                let rule = {};
                for (let column of this.result.columnList) {
                    rule[column.name] = {
                        required: (column.nullable == "NO") && (column.key != "PRI"),
                        max: column.maxLength
                    }
                }
                // disable, have bug
                // this.info.rule = rule
            },
            deleteConfirm(primaryValue) {
                this.$confirm('Are you sure you want to delete this data?', 'Warning', {
                    confirmButtonText: 'OK',
                    cancelButtonText: 'Cancel',
                    type: 'warning'
                }).then(() => {
                    const deleteSql = `DELETE FROM ${this.result.table} WHERE ${this.result.primaryKey}='${primaryValue}'`;
                    this.execute(deleteSql)
                }).catch(() => {
                    this.$message({ type: 'info', message: 'Update canceled' });
                });
            },
            tableRowClassName({ row, rowIndex }) {
                if (!this.result.primaryKey || !this.update.primary) return ''
                if (row[this.result.primaryKey] == this.update.primary) {
                    return 'edit-row';
                }
                return '';
            },
            updateWidth() {
                let width = 0;
                for (const key in this.table.widthItem) {
                    width = width + parseInt(this.table.widthItem[key])
                }
                if (this.result.primaryKey) {
                    width += 60;
                }
                this.table.width = width + 60;

            },
            computeWidth(key, index, value) {
                if (this.table.widthItem[key]) return this.table.widthItem[key];
                if (!index) index = 0
                if (!this.result.data[index] || index > 10) return 60;
                if (!value) {
                    value = this.result.data[index][key];
                }
                var dynamic = value ? ((value + "").length) * 10 : ((key + "").length) * 10;
                if (dynamic > 600) dynamic = 600;
                if (dynamic < 60) dynamic = 60;
                var nextDynamic = this.computeWidth(key, ++index)
                if (dynamic < nextDynamic) dynamic = nextDynamic;
                this.table.widthItem[key] = dynamic;
                this.updateWidth()
                return dynamic;
            },
            celledit(row, column, cell, event) {
                if (row.isFilter) {
                    return;
                }
                cell.contentEditable = true;
                if (this.result.primaryKey) {
                    this.update.primary = row[this.result.primaryKey]
                }
            },
            refresh() {
                if (this.result.sql) {
                    this.toolbar.isRefrsh = true;
                    this.execute(this.result.sql)
                }
            },
            execute(sql) {
                if (!sql) return;
                vscode.postMessage({
                    type: 'execute',
                    sql: sql.replace(/ +/ig, " ")
                });
                this.table.loading = true;
            },
            deleteTemplate() {
                this.result.sql = `DELETE FROM [table] WHERE id= `;
            },
            dataformat0(origin) {
                if (origin == null) return null;
                // bit
                
                if (origin.hasOwnProperty('type')) {
                    return origin.data[0];
                }
                if (Date.parse(origin)) {
                    return origin.toString().replace("T", " ").replace(/\.\d+Z$/, "")
                }
                return origin;
            },
            dataformat(origin) {

                if (origin == undefined || origin == null) {
                    return "<b>(NULL)</b>";
                }

                const preFormat = this.dataformat0(origin)
                if (preFormat != origin) return preFormat;

                return origin;
            },
            clone(obj) {
                let objClone = Array.isArray(obj) ? [] : {};
                if (obj && typeof obj === "object") {
                    for (let key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            objClone[key] = this.dataformat0(obj[key]);
                        }
                    }
                }
                return objClone;
            }, initShowColumn(columnList) {
                this.toolbar.showColumns = []
                for (let i = 0; i < columnList.length; i++) {
                    this.toolbar.showColumns.push(columnList[i].name.toLowerCase());
                }
            }

        },
        computed: {
            columnCount() {
                if (this.result.data == undefined || this.result.data[0] == undefined) return 0;
                return Object.keys(this.result.data[0]).length;
            },
            editorTilte() {
                if (this.update.primary == null) {
                    return 'Insert To ' + this.result.table
                }
                return 'Edit For ' + this.result.table + ' : ' + this.result.primaryKey + '=' + this.update.primary
            },
        }
    })

    const handlerData = (data) => {

        vue.result.sql = data.sql;
        vue.toolbar.sql = data.sql;
        vue.table.widthItem = {}
        vue.result = data;
        vue.table.loading = false
        if (!data.sql.match(/\bwhere\b/ig)) {
            // clear filter
            vue.toolbar.filter = {}
            vue.$refs.dataTable.clearSort()
        }
        if (vue.result.fields) {
            vue.initShowColumn(vue.result.fields)
        }
        if (vue.result.columnList) {
            vue.uploadRole()
            // add filter row
            vue.result.data.unshift({ isFilter: true, content: '' })

        }
        if (vue.toolbar.isRefrsh) {
            vue.toolbar.isRefrsh = false;
        } else {
            vue.info.visible = false;
        }
    }

    const handlerCommon = (res) => {
        vue.editor.loading = false;
        vue.editor.visible = false;
        vue.info.visible = true;
        vue.info.message = res.message
        // vue.$message({ type: 'success', message: `EXECUTE ${res.sql} SUCCESS, affectedRows:${res.affectedRows}` });
    }

    window.addEventListener('message', event => {
        vue.table.loading = false;
        let response = event.data.res;
        if (response.costTime) {
            vue.toolbar.costTime = response.costTime
        }
        switch (event.data.type) {
            case "RUN":
                vue.toolbar.sql = response.sql;
                vue.table.loading = true;
                break;
            case "DATA":
                handlerData(response)
                break;
            case "DML":
            case "DDL":
                handlerCommon(response)
                vue.info.error = false
                vue.refresh()
                break;
            case "ERROR":
                handlerCommon(response)
                vue.info.error = true
                break;
            case "MESSAGE":
                if (response.success) {
                    vue.$message.success(response.message)
                } else {
                    vue.$message.error(response.message)
                }
                break;
            default:
                vue.$message(JSON.stringify(event.data));
        }
    });
    vscode.postMessage({ type: 'init' })
    setInterval(() => {
        // vue.updateWidth()
    }, 100)
</script>

</html>