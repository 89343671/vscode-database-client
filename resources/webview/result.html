<html>

<head>
    <title>result</title>
    <link rel="stylesheet" href="${webviewPath}/css/element.css">
    <script src="${webviewPath}/js/vue.js"></script>
    <script src="${webviewPath}/js/element.js"></script>
    <style>
        body {
            background-color: #F7F7F7;
            font-family: "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif;
        }

        .hint {
            padding: 5px;
            font-size: 17px;
            color: #444;
            display: inline-block;
            margin-top: 8px;
        }

        .cell {
            overflow: hidden !important;
            text-overflow: unset !important;
            white-space: nowrap !important;
            user-select: text !important;
        }
        /*定义滚动条样式（高宽及背景）*/ 
        ::-webkit-scrollbar { 
            /* 滚动条宽度， width：对应竖滚动条的宽度  height：对应横滚动条的高度*/
            /* width: 6px;   
            background: #007acc; */
        } 
        /*定义滚动条轨道（凹槽）样式*/ 
        ::-webkit-scrollbar-track { 
             /* 较少使用 */
            /* -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);   
            border-radius: 3px;  */
        } 
        /*定义滑块 样式*/ 
        ::-webkit-scrollbar-thumb { 
             /* 滚动条滑块长度 */
            /* border-radius: 3px; 
            height: 100px;   
            background-color: #ccc;  */
}
    </style>
</head>

<body>
    <div id="app">
        <div class="hint">
            <el-row style="margin-bottom: 10px;">
                <el-input type="textarea" autosize v-model="result.sql" style="width: 600px;"></el-input>
            </el-row>
            <el-row>
                <el-cow>
                    <el-input v-model="search" style="width:200px" placeholder="Type to search" />
                </el-cow>
                <el-cow>
                    <el-button type="danger" @click='execute'>Execute</el-button>
                </el-cow>
                <el-cow>
                    <span>costTime: </span><span v-text="result.costTime"></span>ms,
                    <span>row: {{result.data.length}}, Col: {{columnCount}}</span>
                </el-cow>
            </el-row>
            <!-- <el-row style="margin-bottom: 10px;">
                <el-input type="textarea" readonly autosize :value="updateSql" v-if="update.where"
                    style="width: 600px;"></el-input>
            </el-row> -->
        </div>
        <div :style="'width:' + tableWidth + 'px;overflow:scroll'">
            <el-table id="dataTable" v-loading='loading' size='small'
                :data="result.data.filter(data => !search || JSON.stringify(data).toLowerCase().includes(search.toLowerCase()))"
                border @cell-click="celledit" @change="generateWhere">
                <el-table-column :label="column" v-for="(column) in result.columnList" :key="column" align="center" @change="generateWhere"
                    v-if="result.columnList" :width="computeWidth(column)">
                    <template slot-scope="scope">
                        <span v-html='dataformat(scope.row[column])' @change="generateWhere"></span>
                    </template>
                </el-table-column>
                <el-table-column :label="key" v-for="(value,key) in result.data[0]" :key="key" align="center"
                    v-if="!result.columnList" :width="computeWidth(key)">
                    <template slot-scope="scope">
                        <span v-html='dataformat(scope.row[key])'></span>
                    </template>
                </el-table-column>
            </el-table>
        </div>
    </div>
</body>

<script>
    const vscode = acquireVsCodeApi();
    // const previousState = vscode.getState();
    const previousState = false;
    const vue = new Vue({
        el: '#app',
        data: {
            result: previousState ? previousState.result : {
                data: [],
                sql: '',
                costTime: 0
            },
            tableWidth: null,
            widthCache: {},
            search: '',
            loading: false,
            update: {
                sql: null,
                where: 'w',
                primary: 'p'
            }

        },
        methods: {
            generateWhere(currentRow, oldCurrentRow) {
                if (!this.update.sql) return;
                this.udpate.sql="hello"
            },
            updateWidth() {
                let width = 0;
                for (const key in this.widthCache) {
                    width = width + parseInt(this.widthCache[key])
                }
                this.tableWidth = width;
            },
            computeWidth(key, index) {

                if (this.widthCache[key]) return this.widthCache[key];
                if (!index) index = 0
                if (!this.result.data[index] || index > 10) return 60;
                var value = this.result.data[index][key];
                var dynamic = value ? ((value + "").length) * 10 : ((key + "").length) * 10;
                if (dynamic > 600) dynamic = 600;
                if (dynamic < 60) dynamic = 60;
                var nextDynamic = this.computeWidth(key, ++index)
                if (dynamic < nextDynamic) dynamic = nextDynamic;
                this.widthCache[key] = dynamic;
                this.updateWidth()
                return dynamic;
            },
            celledit(row, column, cell, event) {
                cell.contentEditable = true;
                // cell.focus()
                if (this.result.primaryKey) {
                    this.update.primary = row[this.result.primaryKey]
                    // this.update.sql=row[this.result.primaryKey]
                }
            },
            execute() {
                vscode.postMessage({
                    type: 'execute',
                    sql: this.result.sql
                });
                if (!this.result.sql.match(/^(alter|create|drop|delete|update|insert)/ig)) {
                    this.loading = true;
                }
            },
            deleteTemplate() {
                this.result.sql = `DELETE FROM [table] WHERE id= `;
            },
            dataformat(origin) {
                if (origin == undefined || origin == null) {
                    return "<b>(NULL)</b>";
                }
                return origin;
            }
        },
        computed: {
            columnCount() {
                if (this.result.data == undefined || this.result.data[0] == undefined) return 0;
                return Object.keys(this.result.data[0]).length;
            }, updateSql() {
                if (this.update.sql && this.update.where) {
                    return this.update.sql.replace('#1', this.update.where).replace('#2', this.update.primary)
                }
                return null;
            }
        }
    })

    window.addEventListener('message', event => {
        vue.result = event.data
        if (event.data.primaryKey && event.data.database && event.data.table) {
            vue.update.sql = `update \`${event.data.database}\`.\`${event.data.table}\`
set #1
where \`${event.data.primaryKey}\`='#2'
`
        }
        vue.loading = false
        vue.widthCache = {}
        // instead by retainContextWhenHidden=true
        // vscode.setState({ result: vue.result });
    });
</script>

</html>